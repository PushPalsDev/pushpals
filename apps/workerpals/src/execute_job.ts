/**
 * Extracted job execution logic.
 * Used by both the host Worker (direct mode) and the Docker job runner.
 */

import { existsSync } from "fs";
import { resolve } from "path";
import { loadPromptTemplate } from "shared";

// ─── Constants ───────────────────────────────────────────────────────────────

/** Job kinds that modify files and should trigger commits */
export const FILE_MODIFYING_JOBS = new Set([
  "file.write",
  "file.patch",
  "file.delete",
  "file.rename",
  "file.copy",
  "file.append",
  "file.mkdir",
  "task.execute",
]);

const MAX_OUTPUT = 256 * 1024;
const OPENHANDS_RESULT_PREFIX = "__PUSHPALS_OH_RESULT__ ";

// ─── Utilities ───────────────────────────────────────────────────────────────

export function shouldCommit(kind: string): boolean {
  return FILE_MODIFYING_JOBS.has(kind);
}

export function truncate(s: string): string {
  return s.length > MAX_OUTPUT ? s.substring(0, MAX_OUTPUT) + "\n… (truncated)" : s;
}

function inferTargetPathFromInstruction(text: string): string | null {
  const patterns = [
    /file\s+(?:called|named)\s+["'`]?([^"'`\s]+)["'`]?/i,
    /create\s+(?:a\s+)?file\s+["'`]?([^"'`\s]+)["'`]?/i,
    /write\s+(?:to|into)\s+["'`]?([^"'`\s]+)["'`]?/i,
  ];
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (!match) continue;
    const raw = (match[1] ?? "").trim().replace(/[.,!?;:]+$/, "");
    if (!raw) continue;
    if (raw.includes("/") || raw.includes("\\") || raw.includes(".")) return raw;
  }
  return null;
}

function toStringArray(value: unknown): string[] {
  if (!Array.isArray(value)) return [];
  return value
    .filter((entry): entry is string => typeof entry === "string")
    .map((entry) => entry.trim())
    .filter(Boolean);
}

function summarizeRecentJobsForDoc(value: unknown, limit = 6): string[] {
  if (!Array.isArray(value)) return [];
  const out: string[] = [];
  for (const row of value) {
    if (!row || typeof row !== "object") continue;
    const job = row as Record<string, unknown>;
    const kind = String(job.kind ?? "").trim();
    const status = String(job.status ?? "").trim();
    const summary = String(job.summary ?? "")
      .replace(/\s+/g, " ")
      .trim();
    const error = String(job.error ?? "")
      .replace(/\s+/g, " ")
      .trim();
    if (!kind && !status && !summary && !error) continue;
    const tail = summary || error;
    const entry = tail ? `- ${kind} [${status}]: ${tail}` : `- ${kind} [${status}]`;
    out.push(entry.slice(0, 220));
    if (out.length >= limit) break;
  }
  return out;
}

async function buildArchitectureDocument(
  repo: string,
  instruction: string,
  recentJobs: unknown,
): Promise<string> {
  const { readdirSync, readFileSync, statSync } = await import("fs");
  const { join } = await import("path");

  const ignore = new Set([
    ".git",
    "node_modules",
    "outputs",
    ".worktrees",
    "workspace",
    ".venv",
    "dist",
    "build",
  ]);

  const list = (dir: string, depth: number, prefix = ""): string[] => {
    if (depth < 0) return [];
    let entries: ReturnType<typeof readdirSync>;
    try {
      entries = readdirSync(dir).sort();
    } catch {
      return [];
    }

    const lines: string[] = [];
    for (const name of entries) {
      if (name.startsWith(".") && name !== ".env.example") continue;
      if (ignore.has(name)) continue;
      const full = join(dir, name);
      let isDir = false;
      try {
        isDir = statSync(full).isDirectory();
      } catch {
        continue;
      }
      lines.push(`${prefix}- ${name}${isDir ? "/" : ""}`);
      if (isDir && depth > 0 && lines.length < 120) {
        lines.push(...list(full, depth - 1, `${prefix}  `));
      }
      if (lines.length >= 120) break;
    }
    return lines;
  };

  const readmePath = join(repo, "README.md");
  let readmeExcerpt = "";
  try {
    readmeExcerpt = readFileSync(readmePath, "utf-8").slice(0, 2400).trim();
  } catch {
    readmeExcerpt = "";
  }

  const lines: string[] = [];
  lines.push("# Repository Architecture");
  lines.push("");
  lines.push(`Requested task: ${instruction}`);
  lines.push("");
  lines.push("## Top-level Structure");
  lines.push(...list(repo, 1));
  if (readmeExcerpt) {
    lines.push("");
    lines.push("## README Excerpt");
    lines.push(readmeExcerpt);
  }
  const jobSummaries = summarizeRecentJobsForDoc(recentJobs);
  if (jobSummaries.length > 0) {
    lines.push("");
    lines.push("## Recent Worker Job Context");
    lines.push(...jobSummaries);
  }
  lines.push("");
  lines.push(
    "Generated by worker task.execute from repository state. Review and refine as needed.",
  );

  return lines.join("\n").trim() + "\n";
}

function useOpenHandsExecutor(): boolean {
  const executor = (process.env.WORKERPALS_EXECUTOR ?? "openhands").trim().toLowerCase();
  if (executor !== "openhands") {
    console.warn(
      `[WorkerPals] Unsupported WORKERPALS_EXECUTOR="${executor}". Only "openhands" is supported.`,
    );
  }
  return true;
}

async function executeWithOpenHands(
  kind: string,
  params: Record<string, unknown>,
  repo: string,
  onLog?: (stream: "stdout" | "stderr", line: string) => void,
): Promise<JobResult> {
  const pythonBin = process.env.WORKERPALS_OPENHANDS_PYTHON ?? "python";
  const scriptPath = resolve(import.meta.dir, "..", "scripts", "openhands_executor.py");
  if (!existsSync(scriptPath)) {
    return {
      ok: false,
      summary: `OpenHands wrapper script not found: ${scriptPath}`,
      exitCode: 1,
    };
  }

  const timeoutMs = Math.max(
    10_000,
    parseInt(process.env.WORKERPALS_OPENHANDS_TIMEOUT_MS ?? "120000", 10) || 120_000,
  );
  const payload = Buffer.from(
    JSON.stringify({
      kind,
      params,
      repo,
      timeoutMs,
    }),
    "utf-8",
  ).toString("base64");

  try {
    const proc = Bun.spawn([pythonBin, scriptPath, payload], {
      cwd: repo,
      stdout: "pipe",
      stderr: "pipe",
    });

    const timer = setTimeout(() => {
      try {
        proc.kill();
      } catch (_e) {}
    }, timeoutMs);

    const [stdout, stderr] = await Promise.all([
      onLog ? streamLines(proc.stdout, "stdout", onLog) : new Response(proc.stdout).text(),
      onLog ? streamLines(proc.stderr, "stderr", onLog) : new Response(proc.stderr).text(),
    ]);
    clearTimeout(timer);
    const exitCode = await proc.exited;

    const lines = stdout.split(/\r?\n/);
    let parsed: Record<string, unknown> | null = null;
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line.startsWith(OPENHANDS_RESULT_PREFIX)) continue;
      const raw = line.slice(OPENHANDS_RESULT_PREFIX.length).trim();
      if (!raw) continue;
      try {
        parsed = JSON.parse(raw) as Record<string, unknown>;
      } catch (_e) {
        parsed = null;
      }
      break;
    }

    const filteredStdout = lines
      .filter((line) => !line.trim().startsWith(OPENHANDS_RESULT_PREFIX))
      .join("\n")
      .trim();

    if (!parsed) {
      return {
        ok: false,
        summary: `OpenHands wrapper did not return a structured result for ${kind}`,
        stdout: truncate(filteredStdout),
        stderr: truncate(stderr),
        exitCode,
      };
    }

    const summary =
      typeof parsed.summary === "string"
        ? parsed.summary
        : exitCode === 0
          ? `${kind} passed via OpenHands`
          : `${kind} failed via OpenHands (exit ${exitCode})`;
    const parsedStdout = typeof parsed.stdout === "string" ? parsed.stdout : filteredStdout;
    const parsedStderr = typeof parsed.stderr === "string" ? parsed.stderr : stderr;
    const parsedExitCode =
      typeof parsed.exitCode === "number" && Number.isFinite(parsed.exitCode)
        ? parsed.exitCode
        : exitCode;
    const parsedOk = typeof parsed.ok === "boolean" ? parsed.ok : parsedExitCode === 0;

    return {
      ok: parsedOk,
      summary,
      stdout: truncate(parsedStdout ?? ""),
      stderr: truncate(parsedStderr ?? ""),
      exitCode: parsedExitCode,
    };
  } catch (err) {
    return {
      ok: false,
      summary: `OpenHands wrapper execution error for ${kind}: ${String(err)}`,
      exitCode: 1,
    };
  }
}

/** Execute a git command and return stdout */
export async function git(
  cwd: string,
  args: string[],
): Promise<{ ok: boolean; stdout: string; stderr: string }> {
  try {
    const proc = Bun.spawn(["git", ...args], {
      cwd,
      stdout: "pipe",
      stderr: "pipe",
    });

    const [stdout, stderr, exitCode] = await Promise.all([
      new Response(proc.stdout).text(),
      new Response(proc.stderr).text(),
      proc.exited,
    ]);

    return { ok: exitCode === 0, stdout: stdout.trim(), stderr: stderr.trim() };
  } catch (err) {
    return { ok: false, stdout: "", stderr: String(err) };
  }
}

// ─── Stream helper ───────────────────────────────────────────────────────────

/**
 * Read a process stream line-by-line, calling onLine for each.
 * Returns the full concatenated output.
 */
export async function streamLines(
  readable: ReadableStream<Uint8Array>,
  streamName: "stdout" | "stderr",
  onLine: (stream: "stdout" | "stderr", line: string) => void,
): Promise<string> {
  const decoder = new TextDecoder();
  const reader = readable.getReader();
  let full = "";
  let buffer = "";

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const chunk = decoder.decode(value, { stream: true });
    full += chunk;
    buffer += chunk;

    const lines = buffer.split("\n");
    buffer = lines.pop() ?? "";

    for (const line of lines) {
      const clean = line.endsWith("\r") ? line.slice(0, -1) : line;
      onLine(streamName, clean);
    }
  }

  // Flush remaining buffer
  if (buffer.length > 0) {
    const clean = buffer.endsWith("\r") ? buffer.slice(0, -1) : buffer;
    onLine(streamName, clean);
  }

  return full;
}

// ─── Git commit creation ─────────────────────────────────────────────────────

/** Create commit for job result and return commit info */
export async function createJobCommit(
  repo: string,
  workerId: string,
  job: {
    id: string;
    taskId: string;
    kind: string;
    params?: Record<string, unknown>;
    sessionId?: string;
    context?: "host" | "docker";
  },
): Promise<{ ok: boolean; branch?: string; sha?: string; error?: string }> {
  const truthy = new Set(["1", "true", "yes", "on"]);
  const requirePush = truthy.has((process.env.WORKERPALS_REQUIRE_PUSH ?? "").toLowerCase());
  const pushAgentBranch =
    requirePush || truthy.has((process.env.WORKERPALS_PUSH_AGENT_BRANCH ?? "").toLowerCase());
  const publicBranchName = `agent/${workerId}/${job.id}`;
  // Keep worker refs out of refs/heads so user-visible branch lists stay clean.
  const hiddenCommitRef = `refs/pushpals/agent/${workerId}/${job.id}`;
  const commitMsg = buildWorkerCommitMessage(workerId, job);
  let completionRef = hiddenCommitRef;
  let hiddenRefCreated = false;

  try {
    let result: { ok: boolean; stdout: string; stderr: string };

    // Stage only the paths implied by this job. This prevents runtime metadata
    // (e.g. workspace/bash_events/*) from being accidentally committed.
    const stageArgs = buildStageCommand(job.kind, job.params);
    if (!stageArgs) {
      return {
        ok: false,
        error: `Unable to determine files to stage for job kind: ${job.kind}`,
      };
    }
    result = await git(repo, stageArgs);
    if (!result.ok) {
      const stageErr = result.stderr || result.stdout;
      if (/pathspec .* did not match any files/i.test(stageErr)) {
        console.warn(
          `[WorkerPals] Stage target missing for ${job.kind}; retrying with fallback "git add -A".`,
        );
        result = await git(repo, [
          "add",
          "-A",
          "--",
          ".",
          ":(exclude)workspace/**",
          ":(exclude)outputs/**",
        ]);
      }
      if (!result.ok) {
        return { ok: false, error: `Failed to stage changes: ${result.stderr || result.stdout}` };
      }
    }

    // Check if there are changes to commit
    result = await git(repo, ["diff", "--cached", "--quiet"]);
    if (result.ok) {
      // No changes to commit (diff exited 0)
      console.log(`[WorkerPals] No changes to commit for job ${job.id}`);
      return { ok: true, branch: hiddenCommitRef, sha: "no-changes" };
    }

    // Commit changes
    result = await git(repo, ["commit", "-m", commitMsg]);
    if (!result.ok) {
      return { ok: false, error: `Failed to commit: ${result.stderr}` };
    }

    // Get commit SHA
    result = await git(repo, ["rev-parse", "HEAD"]);
    if (!result.ok) {
      return { ok: false, error: `Failed to get commit SHA: ${result.stderr}` };
    }
    const sha = result.stdout;

    // Persist commit under an internal ref so it remains reachable after worktree cleanup.
    result = await git(repo, ["update-ref", hiddenCommitRef, sha]);
    if (!result.ok) {
      return { ok: false, error: `Failed to store worker commit ref: ${result.stderr}` };
    }
    hiddenRefCreated = true;

    // Push branch to origin (optional; disabled by default for shared-.git workflows)
    if (pushAgentBranch) {
      result = await git(repo, [
        "push",
        "origin",
        `${hiddenCommitRef}:refs/heads/${publicBranchName}`,
      ]);
      if (!result.ok) {
        const pushError = `Failed to push branch: ${result.stderr || result.stdout}`;
        if (requirePush) {
          if (hiddenRefCreated) {
            await git(repo, ["update-ref", "-d", hiddenCommitRef]);
          }
          return { ok: false, error: pushError };
        }
        console.warn(
          `[WorkerPals] ${pushError}. Continuing with local commit ref only (set WORKERPALS_REQUIRE_PUSH=1 to enforce push).`,
        );
        return { ok: true, branch: completionRef, sha };
      }
      completionRef = publicBranchName;
    } else {
      console.log(
        `[WorkerPals] Skipping push for ${publicBranchName} (WORKERPALS_PUSH_AGENT_BRANCH is disabled).`,
      );
    }

    console.log(`[WorkerPals] Created commit ${sha} on ref ${completionRef}`);
    return { ok: true, branch: completionRef, sha };
  } catch (err) {
    if (hiddenRefCreated) {
      await git(repo, ["update-ref", "-d", hiddenCommitRef]);
    }
    return { ok: false, error: String(err) };
  }
}

function toPath(value: unknown): string | null {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function dedupePaths(paths: Array<string | null>): string[] {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const path of paths) {
    if (!path || seen.has(path)) continue;
    seen.add(path);
    out.push(path);
  }
  return out;
}

function buildStageTargets(kind: string, params?: Record<string, unknown>): string[] {
  const p = params ?? {};
  switch (kind) {
    case "file.write":
    case "file.patch":
    case "file.append":
    case "file.delete":
    case "file.mkdir":
      return dedupePaths([toPath(p.path)]);
    case "file.rename":
    case "file.copy":
      return dedupePaths([toPath(p.from), toPath(p.to)]);
    case "task.execute": {
      const paths = toStringArray(p.paths);
      return dedupePaths([
        ...paths,
        toPath(p.targetPath),
        toPath(p.path),
        inferTargetPathFromInstruction(String(p.instruction ?? p.enhancedPrompt ?? "")),
      ]);
    }
    default:
      return [];
  }
}

function buildStageCommand(kind: string, params?: Record<string, unknown>): string[] | null {
  const targets = buildStageTargets(kind, params);
  if (targets.length === 0) {
    if (kind === "task.execute") {
      return ["add", "-A", "--", ".", ":(exclude)workspace/**", ":(exclude)outputs/**"];
    }
    return null;
  }
  return ["add", "-A", "--", ...targets];
}

function sanitizeCommitValue(value: unknown, max = 140): string {
  const s = String(value ?? "")
    .replace(/\s+/g, " ")
    .trim();
  if (!s) return "";
  return s.length > max ? `${s.slice(0, max - 3)}...` : s;
}

function normalizeCommitType(kind: string, params?: Record<string, unknown>): string {
  const raw = String(params?.commitType ?? params?.changeType ?? params?.type ?? "")
    .trim()
    .toLowerCase();

  const mapped =
    raw === "bugfix" || raw === "bug" || raw === "fix"
      ? "fix"
      : raw === "feature" || raw === "feat" || raw === "new"
        ? "feat"
        : raw === "docs" || raw === "doc"
          ? "docs"
          : raw === "refactor"
            ? "refactor"
            : raw === "chore"
              ? "chore"
              : "";
  if (mapped) return mapped;

  switch (kind) {
    case "file.patch":
      return "fix";
    case "file.delete":
    case "file.rename":
    case "file.copy":
    case "file.append":
    case "file.mkdir":
      return "refactor";
    default:
      return "feat";
  }
}

function normalizeCommitArea(raw: string): string {
  const cleaned = raw
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_")
    .replace(/-+/g, "_")
    .replace(/[^a-z0-9_]/g, "");
  return cleaned || "worker";
}

function inferCommitArea(kind: string, params?: Record<string, unknown>): string {
  const explicit = String(params?.area ?? params?.scope ?? params?.component ?? "").trim();
  if (explicit) return normalizeCommitArea(explicit);

  const targets = buildStageTargets(kind, params);
  const pick = (prefix: string): boolean =>
    targets.some((path) => path.toLowerCase().startsWith(prefix.toLowerCase()));

  if (pick("scripts/start.ts") || pick(".env") || pick(".env.example")) return "startup";
  if (pick("apps/remotebuddy/")) return "remote_agent";
  if (pick("apps/localbuddy/")) return "local_agent";
  if (pick("apps/workerpals/")) return "worker";
  if (pick("apps/source_control_manager/")) return "source_control_manager";
  if (pick("apps/client/")) return "client";
  if (pick("apps/server/")) return "server";
  if (pick("README.md") || pick("docs/")) return "docs";
  return "worker";
}

function summarizeScope(kind: string, params?: Record<string, unknown>): string {
  const targets = buildStageTargets(kind, params);
  if (targets.length === 0) return "repository-level changes";
  const visible = targets.slice(0, 3).join(", ");
  return targets.length > 3 ? `${visible}, +${targets.length - 3} more` : visible;
}

function deriveSummary(action: string, params?: Record<string, unknown>): string {
  const explicit = sanitizeCommitValue(params?.commitSummary, 72);
  if (explicit) return explicit;
  const raw = sanitizeCommitValue(action, 72);
  if (!raw) return "apply requested repository update";
  return raw;
}

function buildImplementationPoints(kind: string, params?: Record<string, unknown>): string {
  const targets = buildStageTargets(kind, params);
  const lines: string[] = [];
  if (targets.length === 0) return "";

  for (const target of targets.slice(0, 5)) {
    lines.push(`- Updated path: ${sanitizeCommitValue(target, 220)}.`);
  }
  if (targets.length > 5) {
    lines.push(`- Updated path: +${targets.length - 5} additional file(s).`);
  }

  return lines.join("\n");
}

function summarizeJobAction(kind: string, params?: Record<string, unknown>): string {
  const p = params ?? {};
  const get = (key: string): string => sanitizeCommitValue(p[key]);

  switch (kind) {
    case "file.write":
      return `write ${get("path") || "<path>"}`;
    case "file.patch":
      return `patch ${get("path") || "<path>"}`;
    case "file.append":
      return `append ${get("path") || "<path>"}`;
    case "file.rename":
      return `rename ${get("from") || "<from>"} -> ${get("to") || "<to>"}`;
    case "file.copy":
      return `copy ${get("from") || "<from>"} -> ${get("to") || "<to>"}`;
    case "file.delete":
      return `delete ${get("path") || "<path>"}`;
    case "file.mkdir":
      return `mkdir ${get("path") || "<path>"}`;
    case "shell.exec":
      return `exec ${get("command") || "<command>"}`;
    case "bun.test":
      return get("filter") ? `test filter=${get("filter")}` : "run bun test";
    case "bun.lint":
      return "run bun lint";
    case "web.fetch":
      return `fetch ${get("url") || "<url>"}`;
    case "web.search":
      return `search ${get("query") || "<query>"}`;
    case "task.execute":
      return `execute ${get("targetPath") || get("path") || inferTargetPathFromInstruction(get("instruction")) || "task"}`;
    default:
      return kind;
  }
}

function buildWorkerCommitMessage(
  workerId: string,
  job: {
    id: string;
    taskId: string;
    kind: string;
    params?: Record<string, unknown>;
    sessionId?: string;
    context?: "host" | "docker";
  },
): string {
  const action = summarizeJobAction(job.kind, job.params);
  const type = normalizeCommitType(job.kind, job.params);
  const area = inferCommitArea(job.kind, job.params);
  const summary = deriveSummary(action, job.params);
  const contextValue = sanitizeCommitValue(job.context ?? "host", 32);
  const sessionValue = sanitizeCommitValue(job.sessionId ?? "", 128);
  const replacements = {
    type: sanitizeCommitValue(type, 16),
    area: sanitizeCommitValue(area, 48),
    summary: sanitizeCommitValue(summary, 72),
    worker_id: sanitizeCommitValue(workerId, 64),
    task_id: sanitizeCommitValue(job.taskId, 128),
    job_id: sanitizeCommitValue(job.id, 128),
    job_kind: sanitizeCommitValue(job.kind, 64),
    action: sanitizeCommitValue(action, 180),
    scope: sanitizeCommitValue(summarizeScope(job.kind, job.params), 220),
    context: contextValue || "host",
    session_line: sessionValue ? `- Session: ${sessionValue}.` : "",
    implementation_points: buildImplementationPoints(job.kind, job.params),
  };

  try {
    return loadPromptTemplate("workerpals/commit_message_prompt.md", replacements).trim();
  } catch (err) {
    console.warn(`[WorkerPals] Failed to load commit message prompt template: ${String(err)}`);
    const fallbackLines = [
      `${replacements.type}(${replacements.area}): ${replacements.summary}`,
      "",
      `- Implementation: ${replacements.action}.`,
      `- Scope: ${sanitizeCommitValue(summarizeScope(job.kind, job.params), 220)}.`,
      `- Traceability: worker:${replacements.worker_id}, task ${replacements.task_id}, job ${replacements.job_id}.`,
      `- Execution context: ${replacements.context}.`,
    ];
    if (replacements.session_line) fallbackLines.push(replacements.session_line);
    return fallbackLines.join("\n");
  }
}

// ─── Job execution ───────────────────────────────────────────────────────────

export interface JobResult {
  ok: boolean;
  summary: string;
  stdout?: string;
  stderr?: string;
  exitCode?: number;
}

export async function executeJob(
  kind: string,
  params: Record<string, unknown>,
  repo: string,
  onLog?: (stream: "stdout" | "stderr", line: string) => void,
): Promise<JobResult> {
  if (useOpenHandsExecutor()) {
    return executeWithOpenHands(kind, params, repo, onLog);
  }

  let cmd: string[];

  switch (kind) {
    case "bun.test": {
      cmd = ["bun", "test"];
      if (params.filter) cmd.push("--filter", params.filter as string);
      break;
    }
    case "bun.lint": {
      cmd = ["bun", "run", "lint"];
      break;
    }
    case "git.status": {
      cmd = ["git", "status", "--porcelain"];
      break;
    }
    case "git.log": {
      const count = Math.min(Number(params.count) || 20, 100);
      cmd = ["git", "log", "--oneline", `--format=%h %s (%an, %ar)`, `-n`, String(count)];
      if (params.branch) cmd.push(params.branch as string);
      break;
    }
    case "git.branch": {
      cmd = params.all === true ? ["git", "branch", "-a", "-v"] : ["git", "branch", "-v"];
      break;
    }
    case "git.diff": {
      cmd = ["git", "diff"];
      break;
    }
    case "file.read": {
      const filePath = params.path as string;
      if (!filePath) return { ok: false, summary: "file.read requires a 'path' param" };
      cmd = ["cat", filePath];
      break;
    }
    case "file.search": {
      const pattern = params.pattern as string;
      if (!pattern) return { ok: false, summary: "file.search requires a 'pattern' param" };
      cmd = ["grep", "-rn", pattern, "."];
      break;
    }
    case "file.list": {
      cmd = ["git", "ls-tree", "--name-only", "-r", "HEAD"];
      break;
    }
    case "ci.status": {
      cmd = [
        "gh",
        "run",
        "list",
        "--limit",
        "5",
        "--json",
        "status,conclusion,name,headBranch,createdAt,url",
      ];
      break;
    }
    case "project.summary": {
      const instruction =
        String(params.instruction ?? params.enhancedPrompt ?? "").trim() ||
        "Summarize repository architecture and key components.";
      const content = await buildArchitectureDocument(repo, instruction, params.recentJobs);
      return {
        ok: true,
        summary: "Generated repository architecture summary",
        stdout: truncate(content),
      };
    }
    case "shell.exec": {
      let command = params.command as string;
      if (!command) return { ok: false, summary: "shell.exec requires a 'command' param" };
      const isWindows = process.platform === "win32";
      cmd = isWindows ? ["cmd", "/c", command] : ["bash", "-c", command];
      break;
    }
    case "task.execute": {
      const instruction = String(params.instruction ?? params.enhancedPrompt ?? "").trim();
      if (!instruction) {
        return { ok: false, summary: "task.execute requires an 'instruction' param" };
      }
      const targetPath =
        (params.targetPath as string | undefined)?.trim() ||
        (params.path as string | undefined)?.trim() ||
        inferTargetPathFromInstruction(instruction);
      if (!targetPath) {
        return {
          ok: false,
          summary:
            "task.execute could not determine output path. Provide targetPath, or run with OpenHands agent mode for instruction-only refactors.",
        };
      }

      const content = await buildArchitectureDocument(repo, instruction, params.recentJobs);
      try {
        const { mkdirSync, writeFileSync } = await import("fs");
        const { dirname, resolve } = await import("path");
        const resolved = resolve(repo, targetPath);
        mkdirSync(dirname(resolved), { recursive: true });
        writeFileSync(resolved, content, "utf-8");
        return {
          ok: true,
          summary: `Executed task and wrote ${targetPath}`,
          stdout: `Wrote ${content.length} bytes to ${targetPath}`,
        };
      } catch (err) {
        return { ok: false, summary: `task.execute error: ${err}` };
      }
    }
    case "file.write": {
      const filePath = params.path as string;
      const content = params.content as string;
      if (!filePath) return { ok: false, summary: "file.write requires a 'path' param" };
      if (content === undefined)
        return { ok: false, summary: "file.write requires a 'content' param" };
      try {
        const { mkdirSync, writeFileSync } = await import("fs");
        const { dirname, resolve } = await import("path");
        const resolved = resolve(repo, filePath);
        mkdirSync(dirname(resolved), { recursive: true });
        writeFileSync(resolved, content, "utf-8");
        return {
          ok: true,
          summary: `Wrote ${content.length} bytes to ${filePath}`,
          stdout: `Wrote ${content.length} bytes to ${filePath}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.write error: ${err}` };
      }
    }
    case "file.patch": {
      const filePath = params.path as string;
      const oldText = params.oldText as string;
      const newText = params.newText as string;
      if (!filePath) return { ok: false, summary: "file.patch requires a 'path' param" };
      if (oldText === undefined)
        return { ok: false, summary: "file.patch requires an 'oldText' param" };
      if (newText === undefined)
        return { ok: false, summary: "file.patch requires a 'newText' param" };
      try {
        const { readFileSync, writeFileSync } = await import("fs");
        const { resolve } = await import("path");
        const resolved = resolve(repo, filePath);
        const current = readFileSync(resolved, "utf-8");
        if (!current.includes(oldText)) {
          return { ok: false, summary: `oldText not found in ${filePath}` };
        }
        const updated = current.replace(oldText, newText);
        writeFileSync(resolved, updated, "utf-8");
        return {
          ok: true,
          summary: `Patched ${filePath}`,
          stdout: `Replaced ${oldText.length} chars with ${newText.length} chars in ${filePath}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.patch error: ${err}` };
      }
    }
    case "file.rename": {
      const from = params.from as string;
      const to = params.to as string;
      if (!from) return { ok: false, summary: "file.rename requires a 'from' param" };
      if (!to) return { ok: false, summary: "file.rename requires a 'to' param" };
      try {
        const { renameSync, mkdirSync } = await import("fs");
        const { resolve, dirname } = await import("path");
        const resolvedFrom = resolve(repo, from);
        const resolvedTo = resolve(repo, to);
        mkdirSync(dirname(resolvedTo), { recursive: true });
        renameSync(resolvedFrom, resolvedTo);
        return {
          ok: true,
          summary: `Renamed ${from} → ${to}`,
          stdout: `Renamed ${from} → ${to}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.rename error: ${err}` };
      }
    }
    case "file.delete": {
      const filePath = params.path as string;
      if (!filePath) return { ok: false, summary: "file.delete requires a 'path' param" };
      try {
        const { statSync, unlinkSync, rmSync } = await import("fs");
        const { resolve } = await import("path");
        const resolved = resolve(repo, filePath);
        const stat = statSync(resolved);
        if (stat.isDirectory()) {
          rmSync(resolved, { recursive: true });
          return {
            ok: true,
            summary: `Deleted directory ${filePath}`,
            stdout: `Deleted directory ${filePath}`,
          };
        } else {
          unlinkSync(resolved);
          return { ok: true, summary: `Deleted ${filePath}`, stdout: `Deleted ${filePath}` };
        }
      } catch (err) {
        return { ok: false, summary: `file.delete error: ${err}` };
      }
    }
    case "file.copy": {
      const from = params.from as string;
      const to = params.to as string;
      if (!from) return { ok: false, summary: "file.copy requires a 'from' param" };
      if (!to) return { ok: false, summary: "file.copy requires a 'to' param" };
      try {
        const { copyFileSync, mkdirSync } = await import("fs");
        const { resolve, dirname } = await import("path");
        const resolvedFrom = resolve(repo, from);
        const resolvedTo = resolve(repo, to);
        mkdirSync(dirname(resolvedTo), { recursive: true });
        copyFileSync(resolvedFrom, resolvedTo);
        return {
          ok: true,
          summary: `Copied ${from} → ${to}`,
          stdout: `Copied ${from} → ${to}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.copy error: ${err}` };
      }
    }
    case "file.append": {
      const filePath = params.path as string;
      const content = params.content as string;
      if (!filePath) return { ok: false, summary: "file.append requires a 'path' param" };
      if (content === undefined)
        return { ok: false, summary: "file.append requires a 'content' param" };
      try {
        const { appendFileSync, mkdirSync } = await import("fs");
        const { resolve, dirname } = await import("path");
        const resolved = resolve(repo, filePath);
        mkdirSync(dirname(resolved), { recursive: true });
        appendFileSync(resolved, content, "utf-8");
        return {
          ok: true,
          summary: `Appended ${content.length} bytes to ${filePath}`,
          stdout: `Appended ${content.length} bytes to ${filePath}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.append error: ${err}` };
      }
    }
    case "file.mkdir": {
      const dirPath = params.path as string;
      if (!dirPath) return { ok: false, summary: "file.mkdir requires a 'path' param" };
      try {
        const { mkdirSync } = await import("fs");
        const { resolve } = await import("path");
        const resolved = resolve(repo, dirPath);
        mkdirSync(resolved, { recursive: true });
        return {
          ok: true,
          summary: `Created directory ${dirPath}`,
          stdout: `Created directory ${dirPath}`,
        };
      } catch (err) {
        return { ok: false, summary: `file.mkdir error: ${err}` };
      }
    }
    case "web.fetch": {
      const url = params.url as string;
      if (!url) return { ok: false, summary: "web.fetch requires a 'url' param" };
      try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 25_000);
        const res = await fetch(url, {
          headers: { "User-Agent": "PushPals/1.0" },
          signal: controller.signal,
        });
        clearTimeout(timer);
        const body = await res.text();
        const contentType = res.headers.get("content-type") ?? "";
        let output = body;
        if (contentType.includes("html")) {
          output = body
            .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
            .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "")
            .replace(/<[^>]+>/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        }
        return {
          ok: res.ok,
          summary: res.ok ? `Fetched ${url} (${output.length} chars)` : `HTTP ${res.status}`,
          stdout: truncate(output),
        };
      } catch (err) {
        return { ok: false, summary: `web.fetch error: ${err}` };
      }
    }
    case "web.search": {
      const query = params.query as string;
      if (!query) return { ok: false, summary: "web.search requires a 'query' param" };
      try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 15_000);
        const searchUrl = `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(query)}`;
        const res = await fetch(searchUrl, {
          headers: { "User-Agent": "PushPals/1.0" },
          signal: controller.signal,
        });
        clearTimeout(timer);
        const html = await res.text();
        const linkRegex = /<a[^>]+href="(https?:\/\/[^"]+)"[^>]*>([^<]+)<\/a>/gi;
        const results: string[] = [];
        let match;
        while ((match = linkRegex.exec(html)) !== null && results.length < 10) {
          if (!match[1].includes("duckduckgo.com")) {
            results.push(`${results.length + 1}. ${match[2].trim()}\n  ${match[1]}`);
          }
        }
        return {
          ok: true,
          summary: `${results.length} search results for "${query}"`,
          stdout: results.length > 0 ? results.join("\n\n") : "No results found.",
        };
      } catch (err) {
        return { ok: false, summary: `web.search error: ${err}` };
      }
    }
    default:
      return { ok: false, summary: `Unknown job kind: ${kind}` };
  }

  try {
    const proc = Bun.spawn(cmd, {
      cwd: repo,
      stdout: "pipe",
      stderr: "pipe",
    });

    const timer = setTimeout(() => {
      try {
        proc.kill();
      } catch (_e) {}
    }, 60_000); // 60s timeout

    const [stdout, stderr] = await Promise.all([
      onLog ? streamLines(proc.stdout, "stdout", onLog) : new Response(proc.stdout).text(),
      onLog ? streamLines(proc.stderr, "stderr", onLog) : new Response(proc.stderr).text(),
    ]);

    clearTimeout(timer);
    const exitCode = await proc.exited;

    return {
      ok: exitCode === 0,
      summary: exitCode === 0 ? `${kind} passed` : `${kind} failed (exit ${exitCode})`,
      stdout: truncate(stdout),
      stderr: truncate(stderr),
      exitCode,
    };
  } catch (err) {
    return { ok: false, summary: `Error executing ${kind}: ${err}` };
  }
}
